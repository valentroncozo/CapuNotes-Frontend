===== src/hooks/useAuth.js =====
// src/hooks/useAuth.js
import { useState, useEffect, useCallback } from "react";

/**
 * Hook centralizado de autenticación.
 * En esta primera versión usa localStorage, pero está preparado
 * para integrarse fácilmente con Keycloak (ver comentarios).
 */

const AUTH_KEY = "capunotes_auth";
const USER_KEY = "capunotes_user";

export default function useAuth() {
  const [isAuthenticated, setIsAuthenticated] = useState(localStorage.getItem(AUTH_KEY) === "1");
  const [user, setUser] = useState(localStorage.getItem(USER_KEY) || "");

  // ---- Login local (temporal) ----
  const login = useCallback((username) => {
    localStorage.setItem(AUTH_KEY, "1");
    localStorage.setItem(USER_KEY, username);
    setUser(username);
    setIsAuthenticated(true);
  }, []);

  // ---- Logout ----
  const logout = useCallback(() => {
    localStorage.removeItem(AUTH_KEY);
    localStorage.removeItem(USER_KEY);
    setIsAuthenticated(false);
    setUser("");
  }, []);

  // ---- Keycloak ready section ----
  // En el futuro, podés reemplazar login/logout por:
  //   import Keycloak from "keycloak-js";
  //   const keycloak = new Keycloak({...});
  //   keycloak.init({ onLoad: "login-required" })
  //   .then(auth => setIsAuthenticated(auth));
  //   y leer keycloak.tokenParsed para user info.

  useEffect(() => {
    // Reactiva sesión persistente al recargar
    const auth = localStorage.getItem(AUTH_KEY) === "1";
    const savedUser = localStorage.getItem(USER_KEY);
    if (auth && savedUser) {
      setIsAuthenticated(true);
      setUser(savedUser);
    }
  }, []);

  return { isAuthenticated, user, login, logout };
}

===== src/hooks/useEntityCrud.js =====
// src/hooks/useEntityCrud.js
import { useCallback, useEffect, useMemo, useState } from "react";
import Swal from "sweetalert2";

/**
 * Hook genérico de CRUD basado en cualquier "service"
 * con interfaz list(), create(), update(), remove().
 *
 * Opciones:
 *  - entityLabel: texto a mostrar en errores ("Área", "Miembro", etc.)
 *  - autoLoad: carga automática al montar (default true)
 */
export default function useEntityCrud(service, { entityLabel = "registro", autoLoad = true } = {}) {
  const [items, setItems] = useState([]);
  const [loading, setLoading] = useState(autoLoad);
  const [error, setError] = useState(null);

  // === LIST ===
  const list = useCallback(async () => {
    setLoading(true);
    setError(null);
    try {
      const data = await service.list();
      setItems(Array.isArray(data) ? data : []);
    } catch (err) {
      console.error("Error list()", err);
      setError("No se pudieron cargar los datos.");
      Swal.fire({
        icon: "error",
        title: "Error",
        text: `No se pudieron cargar ${entityLabel}s.`,
        confirmButtonColor: "#ffc107",
        background: "#11103a",
        color: "#E8EAED",
      });
    } finally {
      setLoading(false);
    }
  }, [service, entityLabel]);

  // === CREATE ===
  const create = useCallback(
    async (payload) => {
      try {
        const created = await service.create(payload);
        setItems((prev) => [...prev, created]);
        return created;
      } catch (err) {
        console.error("Error create()", err);
        handleError(err, `crear ${entityLabel}`);
        throw err;
      }
    },
    [service, entityLabel]
  );

  // === UPDATE ===
  const update = useCallback(
    async (payload) => {
      try {
        const updated = await service.update(payload);
        setItems((prev) => prev.map((x) => (x.id === updated.id ? updated : x)));
        return updated;
      } catch (err) {
        console.error("Error update()", err);
        handleError(err, `actualizar ${entityLabel}`);
        throw err;
      }
    },
    [service, entityLabel]
  );

  // === REMOVE ===
  const remove = useCallback(
    async (id) => {
      try {
        await service.remove(id);
        setItems((prev) => prev.filter((x) => x.id !== id));
        return { ok: true };
      } catch (err) {
        console.error("Error remove()", err);
        handleError(err, `eliminar ${entityLabel}`);
        throw err;
      }
    },
    [service, entityLabel]
  );

  // === ERRORES ===
  const handleError = (err, action = "operar") => {
    let msg = `No se pudo ${action}.`;
    if (err.name === "DuplicateError") msg = err.message;
    else if (err.message) msg = err.message;

    Swal.fire({
      icon: "error",
      title: "Error",
      text: msg,
      confirmButtonColor: "#ffc107",
      background: "#11103a",
      color: "#E8EAED",
    });
  };

  useEffect(() => {
    if (autoLoad) list();
  }, [autoLoad, list]);

  const state = useMemo(
    () => ({ items, loading, error, count: items.length }),
    [items, loading, error]
  );
  const actions = useMemo(() => ({ list, create, update, remove }), [list, create, update, remove]);

  return { ...state, ...actions };
}

===== src/hooks/useAreas.js =====
// src/hooks/useAreas.js
import useEntityCrud from "@/hooks/useEntityCrud.js";
import { areasService } from "@/services/areasService.js";

export default function useAreas() {
  return useEntityCrud(areasService, { entityLabel: "área" });
}

===== src/hooks/useCuerdas.js =====
// src/hooks/useCuerdas.js
import useEntityCrud from "@/hooks/useEntityCrud.js";
import { cuerdasService } from "@/services/cuerdasService.js";

export default function useCuerdas() {
  return useEntityCrud(cuerdasService, { entityLabel: "cuerda" });
}

===== src/hooks/useMiembros.js =====
// src/hooks/useMiembros.js
import useEntityCrud from "@/hooks/useEntityCrud.js";
import { miembrosService } from "@/services/miembrosService.js";

export default function useMiembros() {
  return useEntityCrud(miembrosService, { entityLabel: "miembro" });
}

